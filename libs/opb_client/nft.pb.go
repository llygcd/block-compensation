// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nft.proto

package opb

import (
	bytes "bytes"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BaseNFT defines a non-fungible token
type BaseNFT struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	URI                  string   `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`
	Data                 string   `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	Owner                string   `protobuf:"bytes,5,opt,name=owner,proto3" json:"owner,omitempty"`
	UriHash              string   `protobuf:"bytes,6,opt,name=uri_hash,json=uriHash,proto3" json:"uri_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BaseNFT) Reset()         { *m = BaseNFT{} }
func (m *BaseNFT) String() string { return proto.CompactTextString(m) }
func (*BaseNFT) ProtoMessage()    {}
func (*BaseNFT) Descriptor() ([]byte, []int) {
	return fileDescriptor_eeacf31cf2574f3b, []int{0}
}
func (m *BaseNFT) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BaseNFT.Unmarshal(m, b)
}
func (m *BaseNFT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BaseNFT.Marshal(b, m, deterministic)
}
func (m *BaseNFT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseNFT.Merge(m, src)
}
func (m *BaseNFT) XXX_Size() int {
	return xxx_messageInfo_BaseNFT.Size(m)
}
func (m *BaseNFT) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseNFT.DiscardUnknown(m)
}

var xxx_messageInfo_BaseNFT proto.InternalMessageInfo

// Denom defines a type of NFT
type Denom struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Schema               string   `protobuf:"bytes,3,opt,name=schema,proto3" json:"schema,omitempty"`
	Creator              string   `protobuf:"bytes,4,opt,name=creator,proto3" json:"creator,omitempty"`
	Symbol               string   `protobuf:"bytes,5,opt,name=symbol,proto3" json:"symbol,omitempty"`
	MintRestricted       bool     `protobuf:"varint,6,opt,name=mint_restricted,json=mintRestricted,proto3" json:"mint_restricted,omitempty"`
	UpdateRestricted     bool     `protobuf:"varint,7,opt,name=update_restricted,json=updateRestricted,proto3" json:"update_restricted,omitempty"`
	Description          string   `protobuf:"bytes,8,opt,name=description,proto3" json:"description,omitempty"`
	Uri                  string   `protobuf:"bytes,9,opt,name=uri,proto3" json:"uri,omitempty"`
	UriHash              string   `protobuf:"bytes,10,opt,name=uri_hash,json=uriHash,proto3" json:"uri_hash,omitempty"`
	Data                 string   `protobuf:"bytes,11,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Denom) Reset()         { *m = Denom{} }
func (m *Denom) String() string { return proto.CompactTextString(m) }
func (*Denom) ProtoMessage()    {}
func (*Denom) Descriptor() ([]byte, []int) {
	return fileDescriptor_eeacf31cf2574f3b, []int{1}
}
func (m *Denom) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Denom.Unmarshal(m, b)
}
func (m *Denom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Denom.Marshal(b, m, deterministic)
}
func (m *Denom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Denom.Merge(m, src)
}
func (m *Denom) XXX_Size() int {
	return xxx_messageInfo_Denom.Size(m)
}
func (m *Denom) XXX_DiscardUnknown() {
	xxx_messageInfo_Denom.DiscardUnknown(m)
}

var xxx_messageInfo_Denom proto.InternalMessageInfo

// IDCollection defines a type of collection with specified ID
type IDCollection struct {
	DenomId              string   `protobuf:"bytes,1,opt,name=denom_id,json=denomId,proto3" json:"denom_id,omitempty" yaml:"denom_id"`
	TokenIds             []string `protobuf:"bytes,2,rep,name=token_ids,json=tokenIds,proto3" json:"token_ids,omitempty" yaml:"token_ids"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IDCollection) Reset()         { *m = IDCollection{} }
func (m *IDCollection) String() string { return proto.CompactTextString(m) }
func (*IDCollection) ProtoMessage()    {}
func (*IDCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_eeacf31cf2574f3b, []int{2}
}
func (m *IDCollection) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IDCollection.Unmarshal(m, b)
}
func (m *IDCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IDCollection.Marshal(b, m, deterministic)
}
func (m *IDCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IDCollection.Merge(m, src)
}
func (m *IDCollection) XXX_Size() int {
	return xxx_messageInfo_IDCollection.Size(m)
}
func (m *IDCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_IDCollection.DiscardUnknown(m)
}

var xxx_messageInfo_IDCollection proto.InternalMessageInfo

// Owner defines a type of owner
type Owner struct {
	Address              string         `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	IDCollections        []IDCollection `protobuf:"bytes,2,rep,name=id_collections,json=idCollections,proto3" json:"id_collections" yaml:"idcs"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Owner) Reset()         { *m = Owner{} }
func (m *Owner) String() string { return proto.CompactTextString(m) }
func (*Owner) ProtoMessage()    {}
func (*Owner) Descriptor() ([]byte, []int) {
	return fileDescriptor_eeacf31cf2574f3b, []int{3}
}
func (m *Owner) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Owner.Unmarshal(m, b)
}
func (m *Owner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Owner.Marshal(b, m, deterministic)
}
func (m *Owner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Owner.Merge(m, src)
}
func (m *Owner) XXX_Size() int {
	return xxx_messageInfo_Owner.Size(m)
}
func (m *Owner) XXX_DiscardUnknown() {
	xxx_messageInfo_Owner.DiscardUnknown(m)
}

var xxx_messageInfo_Owner proto.InternalMessageInfo

func init() {
	proto.RegisterType((*BaseNFT)(nil), "proto.BaseNFT")
	proto.RegisterType((*Denom)(nil), "proto.Denom")
	proto.RegisterType((*IDCollection)(nil), "proto.IDCollection")
	proto.RegisterType((*Owner)(nil), "proto.Owner")
}

func init() { proto.RegisterFile("nft.proto", fileDescriptor_eeacf31cf2574f3b) }

var fileDescriptor_eeacf31cf2574f3b = []byte{
	// 490 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x52, 0x4d, 0x6e, 0xd3, 0x40,
	0x14, 0x6e, 0x7e, 0x9d, 0xbc, 0xd0, 0x34, 0x4c, 0x2b, 0x34, 0x65, 0x81, 0x23, 0x0b, 0x89, 0x4a,
	0x88, 0x44, 0x85, 0x05, 0x52, 0x97, 0xa6, 0x42, 0x64, 0x03, 0x92, 0x05, 0x1b, 0x36, 0x61, 0x3c,
	0x33, 0xc4, 0x43, 0x6d, 0x8f, 0x35, 0x33, 0x56, 0xd5, 0x23, 0xb0, 0xe6, 0x02, 0x1c, 0x82, 0x43,
	0xf4, 0x14, 0x96, 0xe8, 0x8a, 0x75, 0x4e, 0x80, 0x3c, 0xe3, 0x04, 0xb3, 0xeb, 0x2a, 0xef, 0xfb,
	0x79, 0x79, 0x9f, 0xbe, 0x31, 0x8c, 0xf3, 0xaf, 0x66, 0x51, 0x28, 0x69, 0x24, 0x1a, 0xd8, 0x9f,
	0xc7, 0xb0, 0x91, 0x1b, 0xe9, 0xa8, 0xe0, 0x47, 0x07, 0xbc, 0x90, 0x68, 0xfe, 0xfe, 0xed, 0x47,
	0x34, 0x85, 0xae, 0x60, 0xb8, 0x33, 0xef, 0x9c, 0x8d, 0xa3, 0xae, 0x60, 0x08, 0x41, 0x3f, 0x27,
	0x19, 0xc7, 0x5d, 0xcb, 0xd8, 0x19, 0x9d, 0x42, 0xaf, 0x54, 0x02, 0xf7, 0x6a, 0x2a, 0xf4, 0xee,
	0x2a, 0xbf, 0xf7, 0x29, 0x5a, 0x45, 0x35, 0x57, 0xdb, 0x19, 0x31, 0x04, 0xf7, 0x9d, 0xbd, 0x9e,
	0xd1, 0x09, 0x0c, 0xe4, 0x75, 0xce, 0x15, 0x1e, 0x58, 0xd2, 0x01, 0x74, 0x0a, 0xa3, 0x52, 0x89,
	0x75, 0x42, 0x74, 0x82, 0x87, 0x56, 0xf0, 0x4a, 0x25, 0xde, 0x11, 0x9d, 0x5c, 0xf4, 0xff, 0xfc,
	0xf4, 0x3b, 0xc1, 0xaf, 0x2e, 0x0c, 0x2e, 0x79, 0x2e, 0xb3, 0x7b, 0x65, 0x7a, 0x04, 0x43, 0x4d,
	0x13, 0x9e, 0x11, 0x17, 0x2b, 0x6a, 0x10, 0xc2, 0xe0, 0x51, 0xc5, 0x89, 0x91, 0xaa, 0xc9, 0xb4,
	0x83, 0x76, 0xe3, 0x26, 0x8b, 0x65, 0xda, 0xe4, 0x6a, 0x10, 0x7a, 0x06, 0x47, 0x99, 0xc8, 0xcd,
	0x5a, 0x71, 0x6d, 0x94, 0xa0, 0x86, 0x33, 0x9b, 0x6f, 0x14, 0x4d, 0x6b, 0x3a, 0xda, 0xb3, 0xe8,
	0x39, 0x3c, 0x2c, 0x0b, 0x46, 0x0c, 0x6f, 0x5b, 0x3d, 0x6b, 0x9d, 0x39, 0xa1, 0x65, 0x9e, 0xc3,
	0x84, 0x71, 0x4d, 0x95, 0x28, 0x8c, 0x90, 0x39, 0x1e, 0xd9, 0x93, 0x6d, 0x0a, 0xcd, 0x5c, 0xab,
	0x63, 0xab, 0xd8, 0x32, 0xdb, 0x15, 0xc1, 0x7f, 0x15, 0xed, 0x7b, 0x9e, 0xfc, 0xeb, 0xb9, 0xa9,
	0xed, 0x1a, 0x1e, 0xac, 0x2e, 0xdf, 0xc8, 0x34, 0xe5, 0xd4, 0xfe, 0xed, 0x02, 0x46, 0xac, 0x6e,
	0x71, 0xbd, 0xab, 0x30, 0x3c, 0xde, 0x56, 0xfe, 0xd1, 0x0d, 0xc9, 0xd2, 0x8b, 0x60, 0xa7, 0x04,
	0x91, 0x67, 0xc7, 0x15, 0x43, 0xe7, 0x30, 0x36, 0xf2, 0x8a, 0xe7, 0x6b, 0xc1, 0x34, 0xee, 0xce,
	0x7b, 0x67, 0xe3, 0xf0, 0x64, 0x5b, 0xf9, 0x33, 0xb7, 0xb0, 0x97, 0x82, 0x68, 0x64, 0xe7, 0x15,
	0xd3, 0xcd, 0xe1, 0xef, 0x1d, 0x18, 0x7c, 0xb0, 0x4f, 0x8b, 0xc1, 0x23, 0x8c, 0x29, 0xae, 0x75,
	0xf3, 0x68, 0x3b, 0x88, 0xbe, 0xc0, 0x54, 0xb0, 0x35, 0xdd, 0xa7, 0x73, 0x17, 0x26, 0x2f, 0x8f,
	0xdd, 0x97, 0xb8, 0x68, 0x27, 0x0f, 0x9f, 0xde, 0x56, 0xfe, 0xc1, 0x5d, 0xe5, 0x1f, 0xb6, 0x59,
	0xbd, 0xad, 0xfc, 0x89, 0xcb, 0x22, 0x18, 0xd5, 0x41, 0x74, 0x28, 0x58, 0x4b, 0x75, 0x59, 0xc2,
	0xd7, 0xb7, 0xbf, 0x9f, 0x1c, 0x7c, 0x3e, 0xdf, 0x08, 0x93, 0x94, 0xf1, 0x82, 0xca, 0x6c, 0x19,
	0x0b, 0x92, 0x7f, 0x13, 0x9c, 0x88, 0x65, 0x9c, 0x4a, 0x7a, 0xf5, 0x82, 0xca, 0xac, 0xe0, 0xb9,
	0x26, 0xf5, 0xd6, 0xd2, 0x1e, 0x5f, 0xca, 0x22, 0x8e, 0x87, 0x76, 0x7c, 0xf5, 0x37, 0x00, 0x00,
	0xff, 0xff, 0xa1, 0xa4, 0x27, 0x8e, 0x31, 0x03, 0x00, 0x00,
}

func (this *BaseNFT) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BaseNFT)
	if !ok {
		that2, ok := that.(BaseNFT)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.URI != that1.URI {
		return false
	}
	if this.Data != that1.Data {
		return false
	}
	if this.Owner != that1.Owner {
		return false
	}
	if this.UriHash != that1.UriHash {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Denom) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Denom)
	if !ok {
		that2, ok := that.(Denom)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Schema != that1.Schema {
		return false
	}
	if this.Creator != that1.Creator {
		return false
	}
	if this.Symbol != that1.Symbol {
		return false
	}
	if this.MintRestricted != that1.MintRestricted {
		return false
	}
	if this.UpdateRestricted != that1.UpdateRestricted {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Uri != that1.Uri {
		return false
	}
	if this.UriHash != that1.UriHash {
		return false
	}
	if this.Data != that1.Data {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *IDCollection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IDCollection)
	if !ok {
		that2, ok := that.(IDCollection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DenomId != that1.DenomId {
		return false
	}
	if len(this.TokenIds) != len(that1.TokenIds) {
		return false
	}
	for i := range this.TokenIds {
		if this.TokenIds[i] != that1.TokenIds[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Owner) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Owner)
	if !ok {
		that2, ok := that.(Owner)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if len(this.IDCollections) != len(that1.IDCollections) {
		return false
	}
	for i := range this.IDCollections {
		if !this.IDCollections[i].Equal(&that1.IDCollections[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
